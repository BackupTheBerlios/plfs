\chapter{Comunicación entre los componentes}

%TODO: señalar qué comunicaciones van encriptadas/desencriptadas

\textbf{\textit{En este capítulo comentamos diferentes implementaciones de la
comunicación entre componentes del sistema. Como veremos, nos centraremos en
los tipos de mensajes en cada tipo de comunicación y la seguridad que debemos
implementar en cada una, para asegurar autenticidad y confidencialidad.}}

Las comunicaciones entre componentes de un mismo nodo funcionan a modo de
llamadas ``normales'' entre partes de un mismo programa (aunque se carguen en
forma de \textit{plugins}).

La comunicación entre componentes de nodos separados se realiza siempre mediante
el paso de mensajes que siguen éste formato:

\begin{enumerate}
	\item IDoperación

	\item Remitente

	\item Datos de la operación (parámetros o resultado)
\end{enumerate}

Seguidamente pasamos a concretar los detalles de comunicación de los diferentes
componentes.



\section{\kplfs $\longleftrightarrow$ \uplfs}

Para que la aplicación en modo usuario pueda enterarse de las operaciones
que se realizan sobre el sistema de ficheros, el módulo \kplfs a nivel de
kernel, debe comunicarse con el módulo \uplfs a nivel usuario.
Para realizar esta comunicación de eventos, hay varias posibilidades:

\begin{description}
	\item [Dispositivo:]
		Aprovecha las propias características de un dispositivo de sistema,
		ya que permite hacer esperas no activas (es decir bloqueantes), a
		través de \textit{poll}, \textit{read}, \textit{select} de un
		dispositivo que implementa \kplfs.

	\item [Compartición de memoria:]
		El problema de esta solución es que requiere una espera activa por
		parte de \uplfs, que debe ir comprobando la zona de memoria compartida
		para ver si hay algún nuevo evento procedente de \kplfs.
\end{description}

Así pues, por las ventajas de operaciones no bloqueantes que ofrece,
utilizaremos un \textbf{dispositivo} para comunicar ambos componentes.

Cuando se realice una operación (\texttt{ls},\texttt{mv}, etc) en el sistema
de ficheros \plfs, el módulo de kernel \kplfs que implementa estas operaciones,
deberá informar dichos eventos al módulo a nivel usuario \uplfs (el cual deberá
realizar las operaciones pertinentes, comunicándose con los diferentes
componentes disponibles).

En éste caso, aunque los componentes estén en el mismo nodo, deben enviarse
mensajes a través del dispositivo de control, mensajes que tienen el mismo
formato que se ha comentado al inicio del capítulo, pero sin el parámetro de
\texttt{Remitente}.



\section{\uplfs/\dpld $\rightarrow$ \pldb}

Llamada interna de funciones.



\section{\uplfs $\longleftrightarrow$ \dpld}

Llamada interna de funciones.



\section{\dpld $\rightarrow$ \dplc}

Todas las comunicaciones van cifradas con $K_{pub_{c}}$ (para asegurar que sólo
los \dplc puedan leer los contenidos) y firmadas con $K_{priv_{d}}$ (para poder
así comprovar su autenticidad).

Luego, en el destino, se comprueba la firma, se descifran los datos y se
procede a realizar la operación.



\section{\dplc $\rightarrow$ \dpld}
\label{sect:warnings}

Todas las comunicaciones van cifradas con $K_{pub_{d}}$ (para asegurar que sólo
los \dplc puedan leer los contenidos) y firmadas con $K_{priv_{c}}$ (para poder
así comprovar su autenticidad).

Luego, en el destino, se comprueba la firma, se descifran los datos y se
procede a realizar la operación.



\section{\dpld/\dplc $\rightarrow$ \umcc}

Cuando tanto \dpld como \dplc quieren comunicarse con un grupo (\dpld se
comunica con el grupo de receptores del slice para mandarles operaciones y
\dplc se comunica con el grupo de emisores para mandarles avisos), lo hacen a
través de la red multicast, mediante el componente de entrada a ella que es
\umcc, de forma que mandan los datos como si fueran directamente una de las dos
comunicaciones anteriores y se transmiten transparentemente por la red \umc.
