\chapter{Diseño de los componentes}

\textbf{\textit{En este capítulo definimos las principales funcionalidades que
deben implementar cada uno de los componentes.}}



\section{\kplfs}

Este módulo implementa la interfaz del VFS (\textit{Virtual File System}, ver
\cite{libfs, lk, lk24i, lkapi, lkmpg, ovfs, tlk}) de Linux, y las operaciones
que permite las hemos descrito en el capítulo anterior en el apartado
\ref{sect:plfsoperations}, emulando el comportamiento de sistemas de ficheros
como Intermezzo \cite{Intermezzo}, CODA o NFS, que tienen un controlador en el
núcleo y otro en espacio de usuario.

Las operaciones que ofrece, además de las del VFS (informar a \kplfs del
resultado de las operaciones del VFS que se comunican a \plfs), son:

\begin{description}
	\item[\texttt{invalidate (slice\_name, node\_name, type, path)}] :\\
		Invalida el fichero determinado por \texttt{path} del slice
		\texttt{slice\_name} del nodo \texttt{node\_name} del tipo
		\texttt{type} (\textit{shared} o \textit{unshared}).
\end{description}



\section{\uplfs}
\label{sect:uplfs}

Cuando el usuario quiere mirar el contenido del directorio de slices o de
nodos de un slice, y \kplfs remite dicha operación a \uplfs, este realiza la
consulta de dicha información llamando a las operaciones que ofrece \pldb, por
ejemplo mediante llamadas a procedimiento remoto (como podría ser Java RMI,
soportado por PlanetLab Central).

Una vez obtenida la información, \uplfs procedería a pasársela a \kplfs el cual
actualizaría los inodos de \plfs y mostraría el resultado al usuario.

Por ello, las operaciones que \uplfs ofrece, además de las del VFS para las que
hace de intermediario hacia \kplfs, son las siguientes:

\begin{description}
	\item[\texttt{execute (component, id, operation, \ldots)}] :\\
		Llama a la función \texttt{operation} del componente
		\texttt{component} con los parámetros extra que se indiquen (en caso
		de indicar alguno), siendo \texttt{id} el identificador de la
		operación para su posible retorno (en Linux sirve perfectamente
		el PID del proceso que inicia la petición, ya que en todo
		momento habrá una sola petición por cada thread).
		\\
		Los posibles componentes actualmente son \dpld o \pldb.

	\item[\texttt{invalidate (slice\_name, node\_name, type, path)}] :\\
		Invalida el fichero determinado por \texttt{path} del slice
		\texttt{slice\_name} del nodo \texttt{node\_name} del tipo
		\texttt{type} (\textit{shared} o \textit{unshared}).
\end{description}



\section{\dpld}

Las operaciones que \dpld ofrece son las siguientes:

\begin{description}
	\item[\texttt{deployToSlice (slice\_name, path\_from, path\_to)}] :\\
		Realiza la comunicación con los componentes \dplc para desplegar
		un fichero \textit{shared} (\texttt{path\_from}) al slice
		\texttt{slice\_name} en \texttt{path\_to}.
		\\
		Para ello, lee el fichero origen y envía los datos al grupo
		multicast que representa el slice a través de \umcc.
		\\
		Ésta operación provoca un aumento del número de versión del
		slice.

	\item[\texttt{deployToNode (slice\_name, node\_name, path\_from,
		path\_to) }] :\\
		Lo mismo que \texttt{deployToSlice} pero hacia un nodo concreto
		para desplegar un fichero \textit{unshared}.

	\item[\texttt{getInfoShared (slice\_name, path)}] :\\
		Hace una petición de información de un objeto \textit{shared}
		del sistema de ficheros del slice \texttt{slice\_name} a un nodo
		cualquiera.
		\\
		Si la petición falla, lo intentará con otro nodo cualquiera,
		hasta llegar a un número máximo de reintentos.

	\item[\texttt{getInfoUnshared (slice\_name, node\_name, path)}] :\\
		Hace una petición de información de un objeto \textit{unshared}
		del sistema de ficheros del slice \texttt{slice\_name} al nodo
		\texttt{node\_name}.
		\\
		Si la operación falla, se reintentará un número finito de veces.

	\item[\texttt{getFileShared (slice\_name, path)}] :\\
		Hace una petición de un objeto \textit{shared} del
		sistema de ficheros del slice \texttt{slice\_name} a un nodo
		cualquiera.
		\\
		Si la petición falla, lo intentará con otro nodo cualquiera,
		hasta llegar a un número máximo de reintentos.

	\item[\texttt{getFileUnshared (slice\_name, node\_name, path)}] :\\
		Hace una petición de un objeto \textit{unshared} del sistema de
		ficheros del slice \texttt{slice\_name} al nodo
		\texttt{node\_name}.
		\\
		Si la operación falla, se reintentará un número finito de veces.

	\item[\texttt{deleteFileShared (slice\_name, path)}] :\\
		Hace la petición de eliminación de un objeto del sistema de
		ficheros (\texttt{path}) de todo el slice \texttt{slice\_name}.
		\\
		Ésta operación provoca un aumento del número de versión del
		slice.

	\item[\texttt{deleteFileUnshared (slice\_name, node\_name, path)}] :\\
		Hace la petición de eliminación de un objeto del sistema de
		ficheros (\texttt{path}) de un nodo \texttt{node\_name} del
		slice \texttt{slice\_name}.
		\\
		Si la operación falla, se reintentará un número finito de veces.

	\item[\texttt{getSliceNodeVersion (slice\_name, node\_name)}] :\\
		Permite obtener la versión del slice \texttt{slice\_name} desde
		el nodo \texttt{node\_name}.

	\item[\texttt{registerNeeded (slice\_name, node\_name)}] :\\
		Petición de necesidad de registro. Si \texttt{node\_name} es
		nulo, se hace un registro a todo el slice \texttt{slice\_name}.

	\item[\texttt{addNodeToSlice (slice\_name, node\_name)}] :\\
		Informa de la adición de un nodo a un slice.

	\item[\texttt{removeNodeFromSlice (slice\_name, node\_name)}] :\\
		Informa de la eliminación de un nodo a un slice.

	\item[\texttt{invalidate (slice\_name, node\_name, type, path)}] :\\
		Invalida un objeto del sistema de ficheros (un fichero o un
		directorio).
\end{description}

En todas las anteriores operaciones, excepto las cuatro últimas, se puede dar el
caso de que el/los \dplc destinatarios de las operaciones no hayan pasado por
un proceso de registro desde el \dpld origen, por lo que se puede recibir un
aviso de necesidad de registro, al cual reaccionará con un registro
(\textit{unicast} o \textit{multicast} según el número de destinatarios de la
operación).



\section{\pldb}

\pldb permite acceder a información relativa a la administración de slices y
nodos de PlanetLab.

Las operaciones que ofrece son:

\begin{description}
	\item[\texttt{getSlices ()}] :\\
		Permite obtener la lista de slices que se han dado de alta en
		PlanetLab

	\item[\texttt{getNodes ()}] :\\
		Permite obtener la lista de nodos que se han dado de alta en
		PlanetLab

	\item[\texttt{getSliceNodes (slice\_name)}] :\\
		Permite obtener la lista de los nodos que hay en un slice

	\item[\texttt{getSliceNodesAny (slice\_name, num)}] :\\
		Permite obtener una lista de \texttt{num} nodos cualesquiera de
		un slice

	\item[\texttt{getSliceNodesNumber (slice\_name)}] :\\
		Permite obtener el numero de nodos que hay en un slice

	\item[\texttt{getSliceNode (slice\_name, node\_name)}] :\\
		Permite obtener información de un nodo de un slice

	\item[\texttt{getSliceNodeAny (slice\_name)}] :\\
		Permite obtener un nodo cualquiera de un slice

	\item[\texttt{getSliceNodeNearest (slice\_name)}] :\\
		Permite obtener el nodo mas cercado de un slice
		(aprovechándose, si se da el caso, de un sistema DNS con
		soporte para ``localidad'').

	\item[\texttt{getNodeSlices (node\_name)}] :\\
		Permite obtener la lista de los slices de un nodo
\end{description}

Para obtener toda esta información, hace falta utilizar la API que ofrece
PlanetLab Central \cite{PLC}.



\section{\umcc}
\label{sect:umcc}

Éste es el módulo cliente de la red multicast, que básicamente tiene las
dos siguientes funcionalidades:

\begin{description}
	\item Enviar los datos al nodo \umcr más cercano para que los haga
		llegar al grupo de destino.

	\item Recibir los datos procedentes de \umcr y hacerlos llegar al
		componente al que van destinados.
\end{description}

El primer caso, se da cuando \dpld ordena el despliegue de una
aplicación/servicio hacia un slice destino. En este caso deberá comunicarse
con el módulo \umcr más cercano para comunicarle los datos necesarios.

El segundo caso, se da cuando un nodo \umcc comunica a \dplc que se debe
desplegar una aplicación/servicio en el nodo dónde éste reside. En este caso
deberá comunicase con él para hacerle llegar los datos.

De modo que las operaciones que ofrece, son:

\begin{description}
	\item[\texttt{group\_id getGroup (group\_name)}] :\\
		Permite obtener el identificador, dentro de la red \umc, de un
		grupo.

	\item[\texttt{setOptions (group\_id, options[])}] :\\
		Permite cambiar las posibles opciones que permita la
		implementación concreta del software multicast que usemos.

	\item[\texttt{getOptions (group\_id, options[])}] :\\
		Permite obtener las posibles opciones que permita la
		implementación concreta del software multicast que usemos.

	\item[\texttt{sendData (group\_id, data)}] :\\
		Permite enviar datos a un grupo.

	\item[\texttt{recieveData (group\_id, data)}] :\\
		Permite recibir datos procedentes de un emisor del grupo.

	\item[\texttt{joinSender (group\_id, node\_name)}] :\\
		Permite añadir un nodo emisor a un grupo multicast.

	\item[\texttt{deleteSender (group\_id, node\_name)}] :\\
		Permite eliminar un nodo emisor de un grupo multicast.

	\item[\texttt{joinReceiver (group\_id, node\_name)}] :\\
		Permite añadir un nodo receptor a un grupo multicast.

	\item[\texttt{deleteReceiver (group\_id, node\_name)}] :\\
		Permite eliminar un nodo receptor de un grupo multicast.
\end{description}

La ventaja de éste módulo es que es totalmente inocuo, por lo que se puede
utilizar la arquitectura de \umc (\umcc + \umcr) en cualquier aplicación, y
permite que se puedan utilizar otros proyectos ya realizados.

Un punto que queda sin controlar es el acceso restringido a la red multicast,
es decir faltaría una autentificación de emisores, por lo que se podrían
realizar ataques DoS desde cualquier máquina a la red.



\section{\umcr}

\nocite{RON}

Estos nodos se encargan de hacer la transmisión multicast, con tal de hacer
llegar los datos a los \umcc del grupo de destino.

Asumiremos que estos nodos pertenecen a un slice administrativo en el cual no se
realizan modificaciones o configuraciones maliciosas.

Como todos los accesos a la red multicast se hacen a través de \umcc, se puede
fácilmente utilizar una implementación ya existente de una red overlay
multicast en modo usuario

En cuanto a las implementaciones, hemos encontrado varias \cite{Araneola, ESM,
LMDD, LSAM, nemo, nemo-res-p2p-mcast, stealth}, pero consideramos que Araneola
\cite{Araneola} se ajusta más a nuestras necesidades que las otras
implementaciones por el hecho de haber sido diseñada para entornos dinámicos y
con la fiabilidad en mente, además de ser un sistema de comunicación de M a N.



\section{\dplc}

Éste módulo, situado en cada una de las máquinas clientes (o receptoras de las
aplicaciones de las que queremos hacer el despliegue), se sitúa en un
slice propio (donde estarán todos los nodos con éste módulo), que
consideraremos administrado correctamente (por lo que no habrá configuraciones
ni modificaciones maliciosas) y al recibir los datos de \umcc accederá a sí
mismo por SSH con tal de poner los ficheros al slice destino y seguidamente
ejecutar el shell script asociado, en caso de estar presente.

Para realizar esta conexión por SSH, el nodo del slice \dplc necesita los datos
de clave y password SSH para que \dplc pueda hacer una conexión a la propia
máquina y acceder a la máquina virtual asociada al slice de destino.

Para ello, se utiliza el proceso de registro descrito en el apartado
\ref{sect:security}. Pero los datos de conexión también puede obtenerse de otro
nodo \textit{peer} \dplc, como se detalla en el apartado
\ref{sect:redeployment}.

De modo que las operaciones que debe implementar este módulo son las
siguientes:

\begin{description}
	\item[\texttt{deployToSlice (slice\_name, path\_to, file, type,
		new\_version)}] :\\
		Despliega el fichero \texttt{file} al path indicado a través de
		la conexión SSH.
		\\
		El fichero puede ser \textit{shared} o \textit{unshared} según
		indique \texttt{type}, guardando siempre una relación de qué
		tipo es cada fichero.
		\\
		Ésta operación provoca un aumento del número de versión del
		slice a \texttt{new\_version}.

	\item[\texttt{getInfo (slice\_name, path)}] :\\
		Obtiene la información de un objeto del sistema de ficheros
		(necesario tanto para listar los contenidos de directorios, como
		para que \dpld los revalide al re-registrarse).

	\item[\texttt{getFile (slice\_name, path)}] :\\
		Hace una petición de un objeto del sistema de ficheros
		del slice \texttt{slice\_name}.

	\item[\texttt{deleteFile (slice\_name, path, new\_version)}] :\\
		Hace la petición de eliminación de un objeto del sistema de
		ficheros (\texttt{path}) de todo el slice \texttt{slice\_name}.
		\\
		Ésta operación provoca un aumento del número de versión del
		slice a \texttt{new\_version}.

	\item[\texttt{getVersion (slice\_name)}] :\\
		Devuelve la versión que el nodo tiene del slice
		\texttt{slice\_name}.

	\item[\texttt{getKey ($K_{pub}$)}] :\\
		Informa de la propia clave pública y devuelve la clave
		pública remota.

	\item[\texttt{getSSH (slice\_name)}] :\\
		Devuelve la clave y password SSH del slice \texttt{slice\_name}.

	\item[\texttt{ping (slice\_name, node\_name, version)}] :\\
		Informa de la versión de despliegue que
		\texttt{node\_name} tiene del slice \texttt{slice\_name}
		desplegada.
		\\
		Como consecuencia, el nodo receptor realiza un \texttt{ping} al
		nodo emisor.

	\item[\texttt{needDeploy (slice\_name, node\_name, path)}] :\\
		Informa de la necesidad a \texttt{node\_name} de recibir un
		deploy de \texttt{path} del slice \texttt{slice\_name}.

	\item[\texttt{registerWithResponse (slice\_name, $K_{SSH}$, $P_{SSH}$,
		$K_{pub}$)}] :\\
		Permite registrarse en un \dplc como integrante del slice emisor
		y devuelve un resultado para informar si se ha podido realizar
		la conexión SSH.

	\item[\texttt{register (slice\_name, $K_{SSH}$, $P_{SSH}$, $K_{pub}$)}]
		:\\
		Permite a \texttt{node\_name} registrarse en \dplc como
		integrante del slice emisor para realizar la conexión SSH.

	\item[\texttt{joined (slice\_name)}] :\\
		Informa de la adición del nodo al grupo multicast del slice
		\texttt{slice\_name}.

	\item[\texttt{deleted (slice\_name)}] :\\
		Informa de la eliminación del nodo al grupo multicast del slice
		\texttt{slice\_name}.

	\item[\texttt{invalidate (slice\_name, path)}] :\\
		Invalida un objeto del sistema de ficheros (un fichero o un
		directorio).
		\\
		Si el fichero estaba en la lista, que \dplc mantiene,
		como \textit{shared}, ejecuta un \texttt{script->stop}.
\end{description}

Como consecuencia de las operaciones de registro, \dplc intenta abrir la
conexión SSH con los datos obtenidos (si no estaba abierta), o los verifica (si
ya estaba abierta), iniciando o reseteando el contador de \textit{timeout} del
registro y arrancando una instancia de \famon para ése slice si no estaba ya en
marcha.

Cuando ``salta'' el \textit{timeout}, si no quedan más registros para ése
slice, se apaga \famon y se cierra la conexión SSH.



\section{\famon}

Éste módulo está situado en las máquinas clientes de la red, y se encarga de
monitorizar los ficheros que han sido desplegados en un nodo de un slice.

Para ello debe haber una instancia corriendo en cada máquina virtual que
corresponda a un slice que funciona a través de \plfs, siendo arrancado por el
correspondiente \dplc en el momento en que hay algún \dpld registrado.

Las operaciones que nos interesan son las siguientes:

\begin{description}
	\item[\texttt{watch (path)}] :\\
		Activa la monitorización sobre \texttt{path}

	\item[\texttt{unwatch (path)}] :\\
		Desactiva la monitorización sobre \texttt{path}

	\item[\texttt{stop ()}] :\\
		Detiene \famon
\end{description}

Hemos encontrado diversas implementaciones \cite{FAM, Gamin}, y de ellas hemos
preferido \textit{Gamin} \cite{Gamin}, por implementar un subconjunto más
sencillo de las operaciones que define el modelo de \textit{FAM} definido por
\textit{SGI} y siendo un programa que consume así menos recursos.
